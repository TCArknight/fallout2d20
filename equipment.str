<?xml version="1.0" encoding="UTF-8"?>

<!-- This file contains the definitions of components associated with equipment such as
      weapons, armor, gear, etc.
-->

<document signature="Hero Lab Structure">

  <!-- Gear component
        All gear must derive from this component
        NOTE! Designate this component as "gear" to enable containment handling.
  -->
  <component
    id="Gear"
    name="Gear"
    isgear="yes"
    autocompset="no"
    ispublic="no"
	addbehavior="never">

    <!-- Stack name field - name is prefixed with the quantity if not a value of one,
          which is important for stackable items that can have varying quantities
    -->
    <field
      id="grStkName"
      name="(Qty) Name"
      type="derived"
      maxfinal="100"
      nevercache="yes">
      <!-- Final value for display consists of the name with a prefixed quantity
            if not one
      -->
      <finalize><![CDATA[
        ~if we have a customized name already, use it; otherwise, use the default name
        var name as string
        if (field[livename].isempty = 0) then
          name = field[livename].text
        else
          name = field[name].text
          endif

        ~if we're not stackable or if our quantity is one, just use the simple name
        if (stackable = 0) then
          @text = name
        elseif (field[stackQty].value = 1) then
          @text = name

        ~prefix the name with the quantity
        else
          @text = "(" & field[stackQty].value & "x) " & name
          endif
        ]]></finalize>
      </field>

    <!-- Gear cost -->
    <field
      id="grCost"
      name="Cost"
      minvalue="0"
      defvalue="0"
      type="derived"
      maxfinal="10">
      <!-- If a "lot cost" is specified, calculate the individual cost from it -->
      <calculate phase="Initialize" priority="5000"><![CDATA[
        ~if we have a 'lot cost', find the cost for a single item by dividing
        ~it by the lot size.
        ~NOTE: The calculate script is only applied to picks - not things - so
        ~     we must also do this calculation in both the Finalize script and
        ~     the TransactionSetup script, so they behave properly on things.
        if (field[grLotCost].value > 0) then
          @value = field[grLotCost].value / field[lotsize].value
          endif
        ]]></calculate>
      <!-- Final value for display has the dollar sign prepended -->
      <finalize><![CDATA[
        ~if this is a thing, we have to determine the value for use below; if we
        ~have a non-zero lot cost, override our value based on the lot cost, else
        ~use multiply the unit code by the lot size. See the Calculate script
        ~comments for more details.
        if (ispick = 0) then
          if (field[grLotCost].value > 0) then
            @value = field[grLotCost].value
          else
            @value = field[grCost].value * field[lotsize].value
            endif
          endif

        ~convert the cost to a value for display appropriately
        if (@value = 0) then
          @text = chr(150)
        else
          var moneyvalue as number
          var money as string
          moneyvalue = @value
          call Money
          @text = money
          endif
        ]]></finalize>
      </field>

    <!-- Gear lot cost - used when you have a set of items that are priced in
          the rulebook as $X for Y items. For example, if 30 bullets cost $10,
          we want 3 bullets to cost $1, but setting grCost to $.33 would yield
          a cost of $0.99. So we specify the lot cost and everything works.
    -->
    <field
      id="grLotCost"
      name="Lot Cost"
      minvalue="0"
      defvalue="0"
      type="static">
      </field>
	  
    <!-- Manage an optional user-assigned name for custom equipment -->
    <field
      id="grUserName"
      name="User Name"
      maxlength="100"
      type="user">
      </field>
	  
    <!-- Synthesized notes about the item -->
    <field
      id="grNotes"
      name="Notes"
      type="derived"
      maxlength="500">
      </field>
		  
    <!-- How common is the item? -->
    <field
      id="grRarity"
      name="Rarity"
      type="derived"
      minvalue="0"
      maxvalue="10">
      </field>
	  
    <!-- Initialize the gear characteristics from our transaction pick (if any) -->
    <creation><![CDATA[
      ~if we don't have a transaction pick to initialize from, bail out; this can
      ~occur if the gear is bootstrapped or auto-added for the actor
      doneif (hero.istransact = 0)

      ~initialize our fields appropriately from the transaction pick
      ~.... add any necessary code here ....
      ]]></creation>

    <!-- Call the appropriate procedures to perform transaction setup, buy, and sell behaviors -->
    <xactsetup><![CDATA[
      ~perform standard transaction setup for the gear
      call XactSetup

      ~initialize any transaction fields appropriately from this piece of gear
      ~.... add code here ....
      ]]></xactsetup>

    <xactbuy><![CDATA[
      call XactBuy
      ]]></xactbuy>

    <xactsell><![CDATA[
      call XactSell
      ]]></xactsell>

    <!-- Accrue the weight of this item into the character, as appropriate -->
    <eval index="1" phase="Effects" priority="10000" name="Accrue Weight"><![CDATA[
      ~if this piece of gear is held by something else, ignore it - we'll get it below
      doneif (isgearheld <> 0)

      ~if this piece of gear is a topmost holder, ignore it - it's not on the character
      doneif (tagis[thing.holder_top] <> 0)

      ~accrue the net weight of this piece of gear into the character
      #traitbonus[trCurrentCarry] += field[gearNet].value
      ]]></eval>

    <!-- Some pieces of gear require modifications -->
    <evalrule index="1" phase="Validate" priority="10000" message="Modification Required!"	><![CDATA[
      ~ if this gear doesn't have a gizmo to handle the mod, we're good.
      ~ validif (isgizmo = 0)
	  
	  ~ if we don't require a mod, we're good.
	  validif (tagis[Equipment.ModRequired] = 0)

	  validif (tagis[ItemModSelected.?] <> 0)
	  
      ~mark the tab as invalid
      linkvalid = 0
      ]]></evalrule>
    </component>


  <!-- Equipment component
        All general non-combat equipment derives from this component
  -->
  <component
    id="Equipment"
    name="Equipment"
    autocompset="no"
    panellink="gear">

    </component>


  <!-- Vehicle component
        All vehicles derive from this component
  -->
  <component
    id="Vehicle"
    name="Vehicle"
    autocompset="no">

    </component>


  <!-- Equippable component
        Any gear that can be equipped (e.g. weapons) must derive from this component.
        A field is managed that tracks whether the gear is actually equipped, and the
        state can be controlled via a checkbox presented to the user. Equipped gear
        automatically accrues the number of hands required to ensure that a character
        doesn't equip more gear than he has hands for.
  -->
  <component
    id="Equippable"
    name="Equippable"
    autocompset="no"
    ispublic="no">

    <!-- Is the gear equipped? -->
    <field
      id="grIsEquip"
      name="Is Equipped?"
      type="user"
      minvalue="0"
      maxvalue="1">
      </field>

    <!-- If the equipment should be selected by default, select it now -->
    <creation><![CDATA[
      ~if this is natural equipment, initialize the equipped state
      if (tagis[Equipment.Natural] <> 0) then
        field[grIsEquip].value = 1
        endif

      ~if this equipment is supposed to start out as equipped, initialize the state
      if (tagis[Equipment.StartEquip] <> 0) then
        field[grIsEquip].value = 1
        endif
      ]]></creation>

    <!-- If we're equipped, assign ourselves the corresponding tag -->
    <eval index="1" phase="Initialize" priority="5000" name="Equipped"><![CDATA[
      if (field[grIsEquip].value <> 0) then
        perform assign[Equipped.Equipped]
        endif
      ]]></eval>

    <!-- If this equipment is a automatically equipped (e.g. a natural attack), we
          can't be moved and we must force the equipped state
    -->
    <eval index="2" phase="Initialize" priority="4000">
      <before name="Equipped"/><![CDATA[
      if (tagis[Equipment.AutoEquip] <> 0) then
        perform assign[Helper.NoMove]
        ~since the equipped field is a "user" field, we need to tell the compiler
        ~not to complain before setting the field
        trustme
        field[grIsEquip].value = 1
        endif
      ]]></eval>

    <!-- If equipped, tell the actor how many hands worth of equipment is equipped -->
    <eval index="3" phase="Final" priority="5000">
      <before name="Check Hands"/><![CDATA[
      ~if not equipped, there's nothing to do
      doneif (field[grIsEquip].value = 0)

      ~if the equipment does not require hands, there's nothing to do
      doneif (tagis[Equipment.NoHands] <> 0)

      ~tell the hero we've got at least one hand used
      perform hero.assign[Hero.Hand]

      ~if the equipment is two-handed, add another hand
      if (tagis[Quality.TwoHanded] <> 0) then
        perform hero.assign[Hero.Hand]
        endif
      ]]></eval>

    <!-- If equipped and we're out of hands, mark ourselves as invalid but don't
        trigger a separate validation error for each weapon -->
    <evalrule index="1" phase="Validate" priority="10000" message="?" issilent="yes"><![CDATA[
      ~if the hero isn't over the hands limit, we're valid
      validif (hero.tagcount[Hero.Hand] <= herofield[acHands].value)

      ~if not equipped, we're valid
      validif (field[grIsEquip].value = 0)

      ~if the equipment does not require any hands, we're valid
      validif (tagis[Equipment.Hand] = 0)

      ~mark the tab as invalid
      linkvalid = 0
      ]]></evalrule>

    <!-- If equipped and held within a container, we have a conflict -->
    <evalrule index="2" phase="Validate" priority="10000" message="Gear is equipped while stored in a container"><![CDATA[
      ~if not both equipped and held within a container, we're valid
      validif (field[grIsEquip].value + isgearheld < 2)

      ~mark the tab as invalid
      linkvalid = 0
      ]]></evalrule>

    </component>


  <!-- WeaponBase component
        All weapons derive from this component. Weapons track a bonus value and damage
        rating, as well as a strength requirement. The net attack value for the weapon
        is calculating, incorporating any penalties that may be applied due to special
        circumstances (e.g. failing to meet the strength requirement).
  -->
  <component
    id="WeaponBase"
    name="Weapon"
    autocompset="no"
    hasshortname="yes"
    panellink="armory"
    ispublic="no">

    <!-- Damage rating of the weapon -->
    <field
      id="wpDamage"
      name="Damage"
      type="derived"
      minvalue="0">
      </field>
	  
    <!-- Synthesized notes about the weapon -->
    <field
      id="wpEffects"
      name="Effects"
      type="derived"
      maxlength="75">
      </field>
	  
    <field
      id="wpQualities"
      name="Qualities"
      type="derived"
      maxlength="75">
      </field>
	  
    <!-- Synthesized notes about the weapon -->
    <field
      id="wpFireRate"
      name="Fire Rate"
      type="derived">
      </field>

    <!-- Minimum strength required to wield -->
    <field
      id="wpStrReq"
      name="Minimum Strength"
      type="static"
	  defvalue="0">
      </field>

    <!-- Special details about the weapon -->
    <field
      id="wpSpecial"
      name="Special"
      type="derived"
      maxlength="300">
      </field>

    <!-- Synthesized notes about the weapon -->
    <field
      id="wpNotes"
      name="Notes"
      type="derived"
      maxlength="500">
      </field>

    <!-- Net attack roll for weapon -->
    <field
      id="wpNetAtk"
      name="Net Attack"
      type="derived">
      </field>

    <!-- Weapon bonus -->
    <field
      id="wpBonus"
      name="Weapon Bonus"
      type="derived">
      </field>

    <!-- Weapon penalty -->
    <field
      id="wpPenalty"
      name="Weapon Penalty"
      type="derived">
      </field>
	
    <!-- Each weapon has an identity used to limit mods to that specific weapon -->
    <identity group="ItemModSpecWpn"/>

    <shadow target="hero">Helper.Shadow</shadow>
	
    <!-- Weapons require one hand by default (unless natural) -->
    <tag group="Equipment" tag="Hand"/>

    <!-- If equipped and the minimum strength isn't satisfied, apply any penalty and
        mark ourselves as not satisfying the requirement -->
    <eval index="1" phase="Final" priority="5000"><![CDATA[
      ~if the minimum strength is satisfied, there's nothing to do
      doneif (field[wpStrReq].value <= #trait[attrStr])

      ~assign a tag to indicate the requirement isn't met
      perform assign[Helper.BadStrReq]

      ~apply any penalty required with the specific weapon
      field[wpPenalty].value = -1

      ~if not equipped, there's nothing more to do
      doneif (field[grIsEquip].value = 0)

      ~apply any general penalty required (e.g. defense penalties or the like)
      ~.... add code here ....
      ]]></eval>

    <!-- Assign any derived special notes to the appropriate field -->
    <eval index="2" phase="Render" priority="1000"><![CDATA[
      var effects as string
      var qualities as string
      var special as string

      ~update the effects
      if (tagis[Effect.?] <> 0) then
        effects = tagnames[Effect.?,", "]
        endif
      field[wpEffects].text = effects

      ~update the qualities
      if (tagis[Quality.?] <> 0) then
        qualities = tagnames[Quality.?,", "]
        endif
      field[wpQualities].text = qualities
	  
      ~append any special attributes appropriately (if any)
      var attribs as string
      attribs = tagnames[Weapon.?,", "]
      special = splice(special,attribs,", ")

      ~append any special details for this weapon
      special = splice(special,field[wpSpecial].text,", ")

      ~we've synthesized the notes for the weapon
      field[wpNotes].text = special
      ]]></eval>

    <!-- Calculate the net attack roll for the weapon -->
    <eval index="3" phase="Final" priority="7000" name="Calc wpNetAtk"><![CDATA[
	  var skillRanks as number
	  var attrVal as number
	  
	  ~ by default, ranged weapons use agility
	  if (tagis[component.WeaponRanged] <> 0) then
	    attrVal = #trait[attrAgi]
	  elseif (tagis[component.WeaponMelee] <> 0) then
	    attrVal = #trait[attrStr] 
		endif
	  
	  ~ skill used is by weapon type
	  if (tagis[WeaponType.BigGun] <> 0) then
	    skillRanks = #trait[skBigGuns]
	  elseif (tagis[WeaponType.Bow] <> 0) then
	    skillRanks = #trait[skAthletics]
	  elseif (tagis[WeaponType.EnergyWpn] <> 0) then
	    skillRanks = #trait[skEnergyWpns]
	  elseif (tagis[WeaponType.Explosive] <> 0) then
	    skillRanks = #trait[skExplosives]
	  elseif (tagis[WeaponType.MeleeWpn] <> 0) then
	    skillRanks = #trait[skMelee]
	  elseif (tagis[WeaponType.SmallGun] <> 0) then
	    skillRanks = #trait[skSmallGuns]
	  elseif (tagis[WeaponType.Throwing] <> 0) then
	    skillRanks = #trait[skThrowing]
	  elseif (tagis[WeaponType.Unarmed] <> 0) then
	    skillRanks = #trait[skUnarmed]
	  else
	    skillRanks = 0
	    endif
	   
	  field[wpNetAtk].value += attrVal + skillRanks
      field[wpNetAtk].value += field[wpBonus].value + field[wpPenalty].value
      ]]></eval>

    <eval index="5" phase="Initialize" priority="5000"><![CDATA[
	
      ~if the minimum strength is satisfied, there's nothing to do
      doneif (tagis[DamageOverride.?] = 0)

      ~apply any penalty required with the specific weapon
      field[wpDamage].value = tagvalue[DamageOverride.?]
	  
      ]]></eval>
	  
    <!-- Check the strength requirement, which we only treat as a problem for things. -->
    <prereq message="Strength requirement not met.">
      <validate><![CDATA[
        ~if this is a pick, we're valid
        ~NOTE! We assume that equipping an item without the strength just applies penalties.
        validif (@ispick <> 0)

        ~verify whether we meet the strength requirement
        validif (#trait[attrStr] >= altthing.field[wpStrReq].value)
        ]]></validate>
      </prereq>

    </component>


  <!-- WeaponRanged component
        Ranged weapons derive from this component. They add range distances for three
        different range classifications. For simplicity, a text-based version of the
        ranges is automatically generated for easy use in displaying the weapon.
        Ranged weapons auto-calculate their net attack value based on the Shooting
        skill.
  -->
  <component
    id="WeaponRanged"
    name="Ranged Weapon"
    autocompset="no">

    <!-- Synthesized text ranges for the weapon -->
    <field
      id="wpRange"
      name="Range"
      type="derived"
      maxlength="10">
      </field>
    <field
      id="wpRangeAbbrev"
      name="Range"
      type="derived"
      maxlength="1">
      </field>
	  
    <!-- All ranged weapons get the same tag for sorting purposes -->
    <tag group="Armory" tag="Range"/>

    <!-- Prepend any derived special notes to the appropriate field -->
    <eval index="1" phase="Render" priority="2000"><![CDATA[
	  var range as string
	  var rangeabbrev as string
      var special as string

      ~set range by tags
	  range = tagnames[Range.?,", "]
	  rangeabbrev = tagabbrevs[Range.?,", "]
	  
      field[wpRange].text = range
      field[wpRangeAbbrev].text = rangeabbrev
	  
      ]]></eval>
	  
    <!-- make sure only 1 of any ItemMods -->
    <evalrule index="1" phase="Render" priority="2000" message="Only 1 mod allowed for "><![CDATA[
	    ~ tag is only added if there is a gizmo with a Receiver, 
		~ so if there isn't one, or only one, we're good.
		
        if (tagcount[ItemModSelected.RangedReceiver] <= 1) then
		  @valid = 1
		  @message &= "Receiver"
		  endif
		
        ]]></evalrule>
    </component>

  <!-- WeaponMelee component
        Melee weapons derive from this component. Melee weapons auto-calculate their
        net attack value based on the Melee skill.
  -->
  <component
    id="WeaponMelee"
    name="Melee Weapon"
    autocompset="no">

    <!-- All melee weapons get the same tag for sorting purposes -->
    <tag group="Armory" tag="Melee"/>

    <!-- All melee weapons get the appropriate tag -->
    <eval index="1" phase="Setup" priority="5000"><![CDATA[
      perform assign[Armory.Melee]
      ]]></eval>
	
	<eval index="2" phase="Final" priority="5000"><![CDATA[
      field[wpDamage].value += #trait[trMeleeDmg]
      ]]></eval>

    </component>
	
  <!-- WeaponEnergy component
        Energy weapons derive from this component.
  -->
  <component
    id="WeaponEnergy"
    name="Energy Weapon"
    autocompset="no">

    <identity group="WeaponEnergy"/> 
	
    <eval index="1" phase="Setup" priority="5000"><![CDATA[
      ~ dummy
	  
      ]]></eval>

    </component>
	
  <!-- WeaponSmallGun component
        Small Gun weapons derive from this component.
  -->
  <component
    id="WeaponSmallGun"
    name="Small Gun Weapon"
    autocompset="no">

    <identity group="WeaponSmallGun"/> 
	
    <eval index="1" phase="Setup" priority="5000"><![CDATA[
      ~ dummy
	  
      ]]></eval>

    </component>
 
  <!-- WeaponBigGun component
        Big Gun weapons derive from this component.
  -->
 <component
    id="WeaponBigGun"
    name="Big Gun Weapon"
    autocompset="no">

    <identity group="WeaponBigGun"/> 
	
    <eval index="1" phase="Setup" priority="5000"><![CDATA[
      ~ dummy
	  
      ]]></eval>

    </component>

  <!-- WeaponThrowing component
        Thrown weapons derive from this component.
  -->
  <component
    id="WeaponThrowing"
    name="Throwing Weapon"
    autocompset="no">

    <identity group="WeaponThrowing"/> 
	
    <eval index="1" phase="Setup" priority="5000"><![CDATA[
      ~ dummy
	  
      ]]></eval>

    </component>
 
  <!-- WeaponBigGun component
        Big Gun weapons derive from this component.
  -->
 <component
    id="WeaponBow"
    name="Bow Weapon"
    autocompset="no">

    <identity group="WeaponBow"/> 
	
    <eval index="1" phase="Setup" priority="5000"><![CDATA[
      ~ dummy
	  
      ]]></eval>

    </component>
	
  <!-- WeaponExplosive component
        Explosive weapons derive from this component.
  -->
  <component
    id="WeaponExplosive"
    name="Explosives"
    autocompset="no">

    <identity group="WeaponExplosive"/> 
	
    <eval index="1" phase="Setup" priority="5000"><![CDATA[
      ~ dummy
	  
      ]]></eval>

    </component>

  <!-- Ammunition component
        Bullets and the like derive from this component. Ammunition blends gear with
        a tracker that lets the user monitor the consumption of the ammunition.
  -->
  <component
    id="Ammunition"
    name="Ammunition"
    autocompset="no">

    <identity group="AmmoType"/>
	
    <!-- Initialize the user value to the new quantity -->
    <creation><![CDATA[
      ~if we don't have a transaction pick to initialize from, use what we know;
      ~this can occur if the gear is bootstrapped or auto-added for the actor
      if (hero.istransact = 0) then
        field[trkUser].value = field[stackQty].value * field[lotsize].value

      ~otherwise, use the contents of the transaction pick to start our value
      else
        field[trkUser].value = hero.transact.field[xactQty].value
        endif
      ]]></creation>
	
    <!-- The tracker quantity should reset to the maximum value -->
    <tag group="Helper" tag="ResetMax"/>

    <!-- Setup our tracker bounds based on the quantity purchased -->
    <eval index="1" phase="Final" priority="1000"><![CDATA[
      field[trkMin].value = 0
      field[trkMax].value = field[stackQty].value
      ]]></eval>

    <!-- Add the quantities from the other pick into this one -->
    <merge><![CDATA[
      field[trkMax].value += altpick.field[trkMax].value
      field[trkUser].value += altpick.field[trkUser].value
      ]]></merge>

    <!-- Split the quantities properly across the two picks -->
    <split><![CDATA[
      ~save the quantity of ammo that still remains unused
      var user as number
      user = field[trkUser].value

      ~update the new "max" values for both picks based on the stack quantity
      field[trkMax].value = field[stackQty].value
      altpick.field[trkMax].value -= altpick.field[stackQty].value

      ~the user value for the first pick is the quantity of ammo still unused,
      ~subject to the maximum size for the pick
      field[trkUser].value = minimum(user,field[trkMax].value)

      ~subtract the quantity allocated to the first pick from what's now left
      user -= field[trkUser].value

      ~if we have any unused ammo left to assign to the other pick, assign it
      if (user <= 0) then
        altpick.field[trkUser].value = 0
      else
        altpick.field[trkUser].value = user
        endif
      ]]></split>

    </component>

	
  <!-- Defense component
        All armor and shields derive from this component. Defensive gear tracks a
        defense rating and a strength requirement. The defense rating is added to the
        character's overall Defense trait when the gear is equipped.
  -->
  <component
    id="Defense"
    name="Defense"
    autocompset="no"
    panellink="armory"
    ispublic="no">

    <!-- Defense adjustment conferred by the equipment -->
    <field
      id="defPhysical"
      name="Physical DR Adjustment"
      type="derived">
      </field>
    <field
      id="defEnergy"
      name="Energy DR Adjustment"
      type="derived">
      </field>
	<field
      id="defRadiation"
      name="Radiation DR Adjustment"
      type="derived">
      </field>
	  
    <!-- Minimum strength required to use the equipment -->
    <field
      id="defStrReq"
      name="Minimum Strength"
      type="static"
	  defvalue="0">
      </field>

    <!-- Special details about the weapon -->
    <field
      id="defSpecial"
      name="Special"
      type="derived"
      maxlength="500">
      </field>

    <!-- Synthesized notes about the defense -->
    <field
      id="defNotes"
      name="Notes"
      type="derived"
      maxlength="500">
      </field>

    <!-- If equipped and the minimum strength isn't satisfied, apply any penalty and
        mark ourselves as not satisfying the requirement -->
    <eval index="1" phase="Final" priority="5000"><![CDATA[
      ~if the minimum strength is satisfied, there's nothing to do
      doneif (field[defStrReq].value <= #trait[attrStr])

      ~assign a tag to indicate the requirement isn't met
      perform assign[Helper.BadStrReq]

      ~if not equipped, there's nothing more to do
      doneif (field[grIsEquip].value = 0)

      ~apply any general penalty required (e.g. defense penalties or the like)
      ~.... add code here ....
      ]]></eval>

    <!-- Apply effects of the equipped armor/shield -->
    <eval index="2" phase="PreTraits" priority="5000">
      <before name="Calc trtFinal"/>
      <after name="Equipped"/><![CDATA[
      ~if this gear is not equipped, skip it
      doneif (field[grIsEquip].value = 0)

      ~apply the appropriate trait adjustments for the equipment
      ~#traitbonus[trDefense] += field[defPhysical].value
	  
	  if (#isheadarmor[] <> 0) then
		#headDRPhys[] += field[defPhysical].value
		#headDREner[] += field[defEnergy].value
		#headDRRad[] += field[defRadiation].value
	    endif
		
      if (#istorsoarmor[] <> 0) then
		#torsoDRPhys[] += field[defPhysical].value
		#torsoDREner[] += field[defEnergy].value
		#torsoDRRad[] += field[defRadiation].value
	    endif
	  
	  if (#isleftarmarmor[] <> 0) then
		#armleftDRPhys[] += field[defPhysical].value
		#armleftDREner[] += field[defEnergy].value
		#armleftDRRad[] += field[defRadiation].value
	    endif
	  
	  if (#isrightarmarmor[] <> 0) then
		#armrightDRPhys[] += field[defPhysical].value
		#armrightDREner[] += field[defEnergy].value
		#armrightDRRad[] += field[defRadiation].value
	    endif
	  
	  if (#isleftlegarmor[] <> 0) then
		#legleftDRPhys[] += field[defPhysical].value
		#legleftDREner[] += field[defEnergy].value
		#legleftDRRad[] += field[defRadiation].value
	    endif
	  
	  if (#isrightlegarmor[] <> 0) then
		#legrightDRPhys[] += field[defPhysical].value
		#legrightDREner[] += field[defEnergy].value
		#legrightDRRad[] += field[defRadiation].value
	    endif
		
      if (#isopticsarmor[] <> 0) then
		#opticDRPhys[] += field[defPhysical].value
		#opticDREner[] += field[defEnergy].value
		#opticDRRad[] += field[defRadiation].value
	    endif
		
      if (#ismainbodyarmor[] <> 0) then
		#mainbodyDRPhys[] += field[defPhysical].value
		#mainbodyDREner[] += field[defEnergy].value
		#mainbodyDRRad[] += field[defRadiation].value
	    endif
		
      if (#isthrusterarmor[] <> 0) then
		#thrusterDRPhys[] += field[defPhysical].value
		#thrusterDREner[] += field[defEnergy].value
		#thrusterDRRad[] += field[defRadiation].value
	    endif
		
      if (#isarm1armor[] <> 0) then
		#arm1DRPhys[] += field[defPhysical].value
		#arm1DREner[] += field[defEnergy].value
		#arm1DRRad[] += field[defRadiation].value
	    endif
		
      if (#isarm2armor[] <> 0) then
		#arm2DRPhys[] += field[defPhysical].value
		#arm2DREner[] += field[defEnergy].value
		#arm2DRRad[] += field[defRadiation].value
	    endif
		
      if (#isarm3armor[] <> 0) then
		#arm3DRPhys[] += field[defPhysical].value
		#arm3DREner[] += field[defEnergy].value
		#arm3DRRad[] += field[defRadiation].value
	    endif
		
		
      ]]></eval>

    <!-- Assign any derived special notes to the appropriate field -->
    <eval index="3" phase="Render" priority="1000"><![CDATA[
      var effects as string
      var qualities as string
      var special as string
	  
      ~append any special attributes appropriately (if any)
      var attribs as string
      attribs = tagnames[ArmorSpecial.?,", "]
      special = splice(special,attribs,", ")

      ~append any special details for this weapon
      special = splice(special,field[defSpecial].text,", ")

      ~we've synthesized the notes for the weapon
      field[defNotes].text = special
      ]]></eval>

    <!-- Check the strength requirement, which we only treat as a problem for things. -->
    <prereq message="Strength requirement not met.">
      <validate><![CDATA[
        ~if this is a pick, we're valid
        ~NOTE! We assume that equipping an item without the strength just applies penalties.
        validif (@ispick <> 0)

        ~verify whether we meet the strength requirement
        validif (#trait[attrStr] >= altthing.field[defStrReq].value)
        ]]></validate>
      </prereq>

    </component>

  <!-- Armor component
        Armor derives from this component. The tracking of multiple pieces of armor
        on the character is automatically managed.
  -->
  <component
    id="Armor"
    name="Armor"
    autocompset="no">

    <!-- Each piece of armor needs its own identity tag to detect multiple pieces being equipped -->
    <identity group="Armor"/>
	
    <!-- Each weapon has an identity used to limit mods to that specific weapon -->
    <identity group="ItemModSpecArmor"/>

    <!-- All armor gets the same tag for sorting purposes -->
    <tag group="Armory" tag="Armor"/>

    <!-- If we're equipped and not a natural form, track the armor on the actor -->
    <eval index="1" phase="Setup" priority="5000" name="Equip Armor"><![CDATA[
      if (field[grIsEquip].value > 0) then
        if (tagis[Equipment.Natural] = 0) then
          perform forward[Armor.?]
          endif
        endif
      ]]></eval>

    <!-- If we're equipped and not a natural form, track the armor on the actor -->
    <eval index="1" phase="Setup" priority="5000" name="Show Location On Hero"><![CDATA[
	  var locTag as string
	  locTag = tagids[ArmorLoc.?,"|"]
	  locTag = replace(locTag,"ArmorLoc.","ArmorWornOn.",0)
	  
      if (field[grIsEquip].value > 0) then
        if (tagis[Equipment.Natural] = 0) then
          perform hero.assignstr[locTag]
          endif
        endif
      ]]></eval>

    <!-- If multiple pieces of armor are equipped, mark ourselves invalid but don't
        flag a separate validation error for each piece -->
    <evalrule index="1" phase="Validate" priority="10000" message="?" issilent="yes"><![CDATA[
      ~if this gear is not equipped, we're valid
      validif (field[grIsEquip].value = 0)

      ~if there are NOT multiple pieces of armor equipped, we're valid
      validif (hero.tagcount[Armor.?] <= 1)

      ~mark the tab as invalid
      linkvalid = 0
      ]]></evalrule>

    </component>

  <!-- Shield component
        Shields derive from this component. The tracking of multiple shields on the
        character is automatically managed.
  -->
  <component
    id="Shield"
    name="Shield"
    autocompset="no">

    <!-- Each shield needs its own identity tag to detect multiple shields being equipped -->
    <identity group="Shield"/>

    <!-- All shields get the same tag for sorting purposes -->
    <tag group="Armory" tag="Shield"/>

    <!-- Shield require one hand by default -->
    <tag group="Equipment" tag="Hand"/>

    <!-- If we're equipped, track the shield on the actor -->
    <eval index="1" phase="Setup" priority="5000" name="Equip Shield"><![CDATA[
      if (field[grIsEquip].value > 0) then
        perform forward[Shield.?]
        endif
      ]]></eval>

    <!-- If multiple shields are equipped, mark ourselves invalid but don't
        flag a separate validation error for each piece -->
    <evalrule index="1" phase="Validate" priority="10000" message="?" issilent="yes"><![CDATA[
      ~if this gear is not equipped, we're valid
      validif (field[grIsEquip].value = 0)

      ~if there are NOT multiple shields equipped, we're valid
      validif (hero.tagcount[Shield.?] <= 1)

      ~mark the tab as invalid
      linkvalid = 0
      ]]></evalrule>

    </component>

  <!-- Apparel component
        Any Apparel derive from this component. This includes Clothing, Outfit and
		Headgear.
  -->
  <component
    id="Apparel"
    name="Base Apparel"
    autocompset="no">

    <identity group="Apparel"/> 
	
    <eval index="1" phase="Setup" priority="5000"><![CDATA[
      ~ dummy
	  
      ]]></eval>

    </component>

  <!-- Clothing component
        Clothing armor derives from this component. 
  -->
  <component
    id="Clothing"
    name="Clothing"
    autocompset="no">
	  
    <!-- Each shield needs its own identity tag to detect multiple shields being equipped -->
    <identity group="Clothing"/>
	
    <!-- Each weapon has an identity used to limit mods to that specific weapon -->
    <identity group="ItemModSpecArmor"/>

    <!-- All shields get the same tag for sorting purposes -->
    <tag group="Armory" tag="Clothing"/>
    <tag group="ArmorType" tag="ApparelClothing"/>
	  
    <!-- If we're equipped, track the shield on the actor -->
    <eval index="1" phase="Setup" priority="5000" name="Equip Clothing"><![CDATA[
      if (field[grIsEquip].value > 0) then
        perform forward[Clothing.?]
        endif
      ]]></eval>

    <!-- If multiple shields are equipped, mark ourselves invalid but don't
        flag a separate validation error for each piece -->
    <evalrule index="1" phase="Validate" priority="10000" message="?" issilent="yes"><![CDATA[
      ~if this gear is not equipped, we're valid
      validif (field[grIsEquip].value = 0)

      ~if there are NOT multiple shields equipped, we're valid
      validif (hero.tagcount[Clothing.?] <= 1)

      ~mark the tab as invalid
      linkvalid = 0
      ]]></evalrule>

    </component>
	
	  <!-- Outfit component
        Clothing armor derives from this component. 
  -->
  <component
    id="Outfit"
    name="Outfit"
    autocompset="no">
	  
    <!-- Each shield needs its own identity tag to detect multiple shields being equipped -->
    <identity group="Outfit"/>
	
    <!-- Each weapon has an identity used to limit mods to that specific weapon -->
    <identity group="ItemModSpecArmor"/>

    <!-- All shields get the same tag for sorting purposes -->
    <tag group="Armory" tag="Clothing"/>
    <tag group="Equipment" tag="Outfit"/>
    <tag group="ArmorType" tag="ApparelOutfit"/>
	  
    <!-- If we're equipped, track the shield on the actor -->
    <eval index="1" phase="Setup" priority="5000" name="Equip Outfit"><![CDATA[
      if (field[grIsEquip].value > 0) then
        perform forward[Outfit.?]
        endif
		
      ]]></eval>

    <!-- If multiple shields are equipped, mark ourselves invalid but don't
        flag a separate validation error for each piece -->
    <evalrule index="1" phase="Validate" priority="10000" message="?" issilent="yes"><![CDATA[
      ~if this gear is not equipped, we're valid
      validif (field[grIsEquip].value = 0)

      ~if there are NOT multiple shields equipped, we're valid
      validif (hero.tagcount[Clothing.?] <= 1)

      ~mark the tab as invalid
      linkvalid = 0
      ]]></evalrule>

    </component>
	
  <component
    id="Headgear"
    name="Headgear"
    autocompset="no">

    <!-- Each shield needs its own identity tag to detect multiple shields being equipped -->
    <identity group="Headgear"/>

    <!-- All shields get the same tag for sorting purposes -->
    <tag group="Armory" tag="Clothing"/>
    <tag group="ArmorType" tag="ApparelHeadgear"/>

    <!-- If we're equipped, track the shield on the actor -->
    <eval index="1" phase="Setup" priority="5000" name="Equip Clothing"><![CDATA[
      if (field[grIsEquip].value > 0) then
        perform forward[Headgear.?]
        endif
      ]]></eval>

    <!-- If multiple headgear are equipped, mark ourselves invalid but don't
        flag a separate validation error for each piece -->
    <evalrule index="1" phase="Validate" priority="10000" message="Too many pieces of headgear equipped!" issilent="yes"><![CDATA[
      ~if this gear is not equipped, we're valid
      validif (field[grIsEquip].value = 0)

      ~if there are NOT multiple headgear equipped, we're valid
      validif (hero.tagcount[Headgear.?] <= 1)

      ~mark the tab as invalid
      linkvalid = 0
      ]]></evalrule>

    </component>

  <!-- PowerArmorBase component
        Base Power Armor component
  -->
  <component
    id="PowerArmorBase"
    name="Base Power Armor"
    autocompset="no">

    <identity group="PowerArmor"/> 
    <identity group="PowerArmorBase"/> 
	
    <eval index="1" phase="Setup" priority="5000"><![CDATA[
      ~ dummy
      ~ the frame is the key to PA, so indicate on the Hero
	  perform forward[PowerArmor.?]
	  
	  ~ Frames are equippable so remove the NoHands tag
	  perform delete[Equipment.NoHands]
      ]]></eval>

    </component>
	
  <component
    id="PowerArmor"
    name="Power Armor Part"
    autocompset="no">
	
	<field
      id="paHealthPoints"
      name="Health Points"
      type="derived">
      </field>
	
	<field
      id="paComponents"
      name="Installed Components"
      type="derived"
      maxlength="300">
      </field>
	
    <identity group="ItemModSpecPwrArm"/>
	
    <tag group="Equipment" tag="NoHands"/>
		
    <eval index="1" phase="Setup" priority="5000"><![CDATA[
      
	  ~ dummy
      ]]></eval>
	  
    <!-- Each talent costs 1 slot --> 
    <eval index="3" phase="Traits" priority="10000">
      <before name="Calc resLeft"/>
      <after name="Bound trtUser"/><![CDATA[
      ~dummy
      
      ]]></eval> 
	  
    </component>

  <component
    id="Robot"
    name="Robot Body Part"
    autocompset="no"
	panellink="origin">

    <identity group="RobotPart"/> 
    <identity group="RobotHasPart"/> 
	
    <shadow target="hero">Helper.Shadow</shadow>
	
    <eval index="1" phase="Setup" priority="5000"><![CDATA[
      perform forward[RobotHasPart.?]
      ]]></eval>
	  
    <!-- Each talent costs 1 slot --> 
    <eval index="3" phase="Traits" priority="10000">
      <before name="Calc resLeft"/>
      <after name="Bound trtUser"/><![CDATA[
      ~if this skill is not added directly to the hero (i.e. an advance), skip it entirely
      doneif (origin.ishero = 0)

      ~adjust the resource appropriately
	  ~ decrement part resource
	  if (tagis[RobotBody.Arm] <> 0) then
	    hero.child[resRobotArms].field[resSpent].value += 1
	    endif
      
	  if (tagis[RobotBody.Body] <> 0) then
	    hero.child[resRobotBody].field[resSpent].value += 1
	    endif
      ]]></eval> 
	  
    </component>	
	
  <!-- Define various component sets associated with the components defined above.
  -->

  <!-- No compsets are auto-defined for the component -->
  <!-- Explosive - Explosive ranged weapons -->
  <compset
    id="Explosive"
    stackable="yes">
    <compref component="WeaponBase"/>
    <compref component="WeaponExplosive"/>
    <compref component="WeaponRanged"/>
    <compref component="Equippable"/>
    <compref component="Gear"/>
    <compref component="Custom"/>
    </compset>
	
  <!-- Big Guns - big gun style ranged weapons -->
  <compset
    id="Bow"
    stackable="yes">
    <compref component="WeaponBase"/>
    <compref component="WeaponBow"/>
    <compref component="WeaponRanged"/>
    <compref component="Equippable"/>
    <compref component="Gear"/>
    <compref component="Custom"/>
    </compset>
	
  <!-- Small Guns - small gun style ranged weapons -->
  <compset
    id="SmallGun"
    stackable="yes">
    <compref component="WeaponBase"/>
    <compref component="WeaponSmallGun"/>
    <compref component="WeaponRanged"/>
    <compref component="Equippable"/>
    <compref component="Gear"/>
    <compref component="Custom"/>
    </compset>
	
  <!-- Big Guns - big gun style ranged weapons -->
  <compset
    id="BigGun"
    stackable="yes">
    <compref component="WeaponBase"/>
    <compref component="WeaponBigGun"/>
    <compref component="WeaponRanged"/>
    <compref component="Equippable"/>
    <compref component="Gear"/>
    <compref component="Custom"/>
    </compset>
	
  <!-- Energy - energy-based ranged weapons -->
  <compset
    id="Throwing"
    stackable="yes">
    <compref component="WeaponBase"/>
    <compref component="WeaponThrowing"/>
    <compref component="WeaponRanged"/>
    <compref component="Equippable"/>
    <compref component="Gear"/>
    <compref component="Custom"/>
    </compset>
	
  <!-- Energy - energy-based ranged weapons -->
  <compset
    id="Energy"
    stackable="yes">
    <compref component="WeaponBase"/>
    <compref component="WeaponEnergy"/>
    <compref component="WeaponRanged"/>
    <compref component="Equippable"/>
    <compref component="Gear"/>
    <compref component="Custom"/>
    </compset>
	
  <!-- Ranged - ranged weapons -->
  <compset
    id="Ranged"
    stackable="yes">
    <compref component="WeaponBase"/>
    <compref component="WeaponRanged"/>
    <compref component="Equippable"/>
    <compref component="Gear"/>
    <compref component="Custom"/>
    </compset>

  <!-- Melee - melee weapons -->
  <compset
    id="Melee"
    stackable="yes">
    <compref component="WeaponBase"/>
    <compref component="WeaponMelee"/>
    <compref component="Equippable"/>
    <compref component="Gear"/>
    <compref component="Custom"/>
    </compset>

  <!-- Weapon - all weapons (above) must include these fields -->
  <compset
    id="Weapon"
    stackable="yes">
    <compref component="WeaponBase"/>
    <compref component="Equippable"/>
    <compref component="Gear"/>
    </compset>

  <!-- Armor -->
  <compset
    id="Armor"
    stackable="yes">
    <compref component="Armor"/>
    <compref component="Defense"/>
    <compref component="Equippable"/>
    <compref component="Gear"/>
    <compref component="Custom"/>
    </compset>

  <!-- Shield -->
  <compset
    id="Shield"
    stackable="yes">
    <compref component="Shield"/>
    <compref component="Defense"/>
    <compref component="Equippable"/>
    <compref component="Gear"/>
    </compset>

  <!-- Clothing -->
  <compset
    id="Clothing"
    stackable="yes">
    <compref component="Clothing"/>
    <compref component="Apparel"/>
    <compref component="Defense"/>
    <compref component="Equippable"/>
    <compref component="Gear"/>
    <compref component="Custom"/>
    </compset>
	
  <!-- Outfit -->
  <compset
    id="Outfit"
    stackable="yes">
    <compref component="Outfit"/>
    <compref component="Apparel"/>
    <compref component="Defense"/>
    <compref component="Equippable"/>
    <compref component="Gear"/>
    <compref component="Custom"/>
    </compset>
	
  <compset
    id="Headgear"
    stackable="yes">
    <compref component="Headgear"/>
    <compref component="Apparel"/>
    <compref component="Defense"/>
    <compref component="Equippable"/>
    <compref component="Gear"/>
    <compref component="Custom"/>
    </compset>
	
  <!-- Defense - all armor and shields (above) must include these fields -->
  <compset
    id="Defense"
    stackable="yes">
    <compref component="Defense"/>
    <compref component="Equippable"/>
    <compref component="Gear"/>
    </compset>

  <!-- Equipment -->
  <compset
    id="Equipment"
    stackable="yes">
    <compref component="Equipment"/>
    <compref component="Gear"/>
    <compref component="Custom"/>
    </compset>

  <!-- Ammunition -->
  <compset
    id="Ammunition"
    stackable="yes">
    <compref component="Equipment"/>
    <compref component="Gear"/>
    <compref component="Custom"/>
    <compref component="Ammunition"/>
    <compref component="Tracker"/>
    </compset>

  <!-- Vehicle -->
  <compset
    id="Vehicle">
    <compref component="Vehicle"/>
    <compref component="Gear"/>
    </compset>

  <!-- Robot Body -->
  <compset
    id="Robot">
    <compref component="Robot"/>
    <compref component="Gear"/>
    <compref component="Custom"/>
    </compset>	

  <!-- Power Armor -->
  <compset
    id="PowerArmorBase">
    <compref component="PowerArmor"/>
    <compref component="PowerArmorBase"/>
    <compref component="Defense"/>
    <compref component="Equippable"/>
    <compref component="Gear"/>
    <compref component="Custom"/>
    </compset>	
	
  <compset
    id="PowerArmor">
    <compref component="PowerArmor"/>
    <compref component="Defense"/>
    <compref component="Equippable"/>
    <compref component="Gear"/>
    <compref component="Custom"/>
    </compset>	

  </document>
